{"version":3,"file":"component---src-mdx-comparing-splink-models-unsupervised-mdx-acaf026207d978871dbc.js","mappings":"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","sources":["webpack://robinlinacre/./src/mdx/comparing_splink_models_unsupervised.mdx","webpack://robinlinacre/./src/components/Subtitle.jsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nimport {MDXLayout} from \"../components/MDXLayout\";\nimport {SEO} from \"../components/SEO\";\nexport const Head = props => React.createElement(SEO, {\n  frontmatter: props.pageContext.frontmatter\n});\nimport {Vega, VegaLite} from \"react-vega\";\nimport Subtitle from '../components/Subtitle';\nimport roc_comparison_cluster from \"./comparing_splink_models/roc_comparison_trained_block_cluster.vl.json\";\nimport roc_comparison_no_cluster from \"./comparing_splink_models/roc_comparison_trained_block_no_cluster.vl.json\";\nimport iterations from \"./comparing_splink_models/iterations.vl.json\";\nimport comp_1 from \"./comparing_splink_models/param_comparison_model_01_two_levels.vl.json\";\nimport comp_2 from \"./comparing_splink_models/param_comparison_model_02_fuzzy_simple.vl.json\";\nimport comp_3 from \"./comparing_splink_models/param_comparison_model_03_fuzzy_complex.vl.json\";\nimport comp_4 from \"./comparing_splink_models/param_comparison_model_04_fuzzy_complex_and_tf.vl.json\";\nimport comp_5 from \"./comparing_splink_models/param_comparison_model_05_fuzzy_complex_and_tf_weights.vl.json\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    h2: \"h2\",\n    p: \"p\",\n    a: \"a\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h1, null, \"Are more complex probabilistic linkage models more accurate?\"), \"\\n\", React.createElement(Subtitle, null, \" Part 2: Unsupervised learning \"), \"\\n\", React.createElement(_components.h2, null, \"Introduction\"), \"\\n\", React.createElement(_components.p, null, \"In \", React.createElement(_components.a, {\n    href: \"https://www.robinlinacre.com/comparing_splink_models/\"\n  }, \"part 1\"), \" of this post, I showed that more complex probabilistic linkage models can be dramatically more accurate than simple models. I used supervised learning to compute the model parameters directly from ground truth data to ensure a fair comparison. This meant that differences in performance could be attributed solely to the different model formulations, rather than the process of estimation.\"), \"\\n\", React.createElement(_components.p, null, \"I also used the labelled data to ensure that match scores were computed for all true matches, in addition to being computed for non-matching comparisons that met a \", React.createElement(_components.a, {\n    href: \"https://github.com/moj-analytical-services/splink_synthetic_data_performance_comparisons/blob/8daa5dbddae7079c2569609a00c57fd0c7c60559/model_training/person/uk_citizens_max_groupsize_20/compare_models/00_estimate_m_u/glue_py_resources/splink_settings.py#L52\"\n  }, \"list of blocking rules\"), \". This meant that the results were not strongly dependent on the blocking approach.\"), \"\\n\", React.createElement(_components.p, null, \"In real applications of record linkage, we typically do not have ground truth data. This post explores whether the findings change if the same models are trained using unsupervised learning. Specifically, model parameters will be estimated using \", React.createElement(_components.a, {\n    href: \"https://github.com/moj-analytical-services/splink\"\n  }, \"Splink\"), \".\"), \"\\n\", React.createElement(_components.p, null, \"I find that the gains in accuracy from more complex models are similar, and seem little affected by the differences between estimated parameters and their true values.\"), \"\\n\", React.createElement(_components.p, null, \"I also find that convergence of the Expectation Maximisation algorithm is significantly faster for more complex models. This is not surprising: a more complex model more accurately describes the data, leading to more precise predictions on each iteration of the algorithm.\"), \"\\n\", React.createElement(_components.p, null, \"I also find evidence that the more accurate models seem to have greatest advantage when predicting the match status of some of the most hard-to-find matches. This may imply that, in models where blocking rules are very tight, the more complex models have less of a comparative advantage. That would make intuitive sense, since tight blocking rules pick out easier-to-match record comparisons, many of which are likely to be easy to match even with a very simple model.\"), \"\\n\", React.createElement(_components.h2, null, \"Results\"), \"\\n\", React.createElement(_components.p, null, \"First I present ROC curves on the same basis as in Part 1, but using estimated parameters rather than their true values. For this chart, the ground truth data has been used to ensure that all true matches are included in the ROC curve. The blocking rules for this ROC curve are \", React.createElement(_components.a, {\n    href: \"https://github.com/moj-analytical-services/splink_synthetic_data_performance_comparisons/blob/8daa5dbddae7079c2569609a00c57fd0c7c60559/model_training/person/uk_citizens_max_groupsize_20/compare_models/00_estimate_m_u/glue_py_resources/splink_settings.py#L52\"\n  }, \"here\"), \".\"), \"\\n\", React.createElement(VegaLite, {\n    spec: roc_comparison_cluster\n  }), \"\\n\", React.createElement(_components.p, null, \"Second, I present a ROC curve where record comparisons are generated from a \", React.createElement(_components.a, {\n    href: \"https://github.com/moj-analytical-services/splink_synthetic_data_performance_comparisons/blob/657785f786d5e6ae532a8da221cc0fbab2f2b017/model_training/person/uk_citizens_max_groupsize_20/compare_trained_models/03_combine_blocks/job.py#L113\"\n  }, \"list of blocking rules\"), \". This is a better approximation of a real-life record linkage scenario, in which we have to use blocking rules to try and recover all positive matches.\"), \"\\n\", React.createElement(VegaLite, {\n    spec: roc_comparison_no_cluster\n  }), \"\\n\", React.createElement(_components.p, null, \"This second ROC curve achieves lower recall (true positive rate) because the blocking rules fail to detect a fairly large number of true matches. These records are therefore scored as certain non-matches.\"), \"\\n\", React.createElement(_components.h2, null, \"Methodology\"), \"\\n\", React.createElement(_components.p, null, \"Model training was performed using Splink. Specifically, I \", React.createElement(_components.a, {\n    href: \"https://github.com/moj-analytical-services/splink_synthetic_data_performance_comparisons/blob/61d17078fbf705f9d5c6e848efd6c50f4a5008e5/model_training/person/uk_citizens_max_groupsize_20/compare_trained_models/00_estimate_u/job.py#L121\"\n  }, \"estimated u values directly\"), \", and then used the expectation maximisation algorithm to estimate m values (e.g. \", React.createElement(_components.a, {\n    href: \"https://github.com/moj-analytical-services/splink_synthetic_data_performance_comparisons/blob/61d17078fbf705f9d5c6e848efd6c50f4a5008e5/model_training/person/uk_citizens_max_groupsize_20/compare_trained_models/01_block_postcode_dob/job.py#L133\"\n  }, \"here\"), \") and the \", React.createElement(_components.a, {\n    href: \"https://github.com/moj-analytical-services/splink_synthetic_data_performance_comparisons/blob/61d17078fbf705f9d5c6e848efd6c50f4a5008e5/model_training/person/uk_citizens_max_groupsize_20/compare_trained_models/03_combine_blocks/job.py#L109\"\n  }, \"proportion of matches parameter\"), \".\"), \"\\n\", React.createElement(_components.p, null, \"Exactly the same \", React.createElement(_components.a, {\n    href: \"https://github.com/moj-analytical-services/splink_synthetic_data_performance_comparisons/blob/61d17078fbf705f9d5c6e848efd6c50f4a5008e5/model_training/person/uk_citizens_max_groupsize_20/compare_trained_models/00_estimate_u/glue_py_resources/splink_settings.py#L62\"\n  }, \"model specifications\"), \" were used as in Part 1 of this post.\"), \"\\n\", React.createElement(_components.p, null, \"Reproducibility materials can be found \", React.createElement(_components.a, {\n    href: \"https://github.com/moj-analytical-services/splink_synthetic_data_performance_comparisons/releases/tag/v0.4\"\n  }, \"here\"), \".\"), \"\\n\", React.createElement(_components.h2, null, \"Other findings\"), \"\\n\", React.createElement(_components.p, null, \"There were two other interesting findings.\"), \"\\n\", React.createElement(_components.p, null, \"First, the more complex models trained in fewer iterations. That is, convergence of the Expectation Maximisation algorithm is significantly faster for the more complex models.\"), \"\\n\", React.createElement(VegaLite, {\n    spec: iterations\n  }), \"\\n\", React.createElement(_components.p, null, \"Second, the m values estimated by the models were different from their true values by a fairly large margin, and this pattern was consistent across all models.\"), \"\\n\", React.createElement(_components.p, null, \"What may be the cause?\"), \"\\n\", React.createElement(_components.p, null, \"The m values are computed from running the expectation maximisation algorithm on a subset of blocked record comparisons. If the blocking rules select a biased sample of records, then the estimated m values will also be biased.\"), \"\\n\", React.createElement(_components.p, null, \"There is good reason to believe this may be the case. For example, for estimation of the parameters on first name and surname, I \", React.createElement(_components.a, {\n    href: \"https://github.com/moj-analytical-services/splink_synthetic_data_performance_comparisons/blob/61d17078fbf705f9d5c6e848efd6c50f4a5008e5/model_training/person/uk_citizens_max_groupsize_20/compare_trained_models/01_block_postcode_dob/job.py#L107\"\n  }, \"block on date of birth and postcode\"), \". But records where date of birth and postcode match are likely to be higher quality records overall, and so there is less likely to be an error in forename or surname than for an average matching record. This would be expected to cause the m value for a match to be estimated too high.\"), \"\\n\", React.createElement(_components.p, null, \"The following charts show a comparison of estimated parameter estimates vs their true values for all five estimated models.\"), \"\\n\", React.createElement(_components.h3, null, \"Model 1\"), \"\\n\", React.createElement(VegaLite, {\n    spec: comp_1\n  }), \"\\n\", React.createElement(_components.h3, null, \"Model 2\"), \"\\n\", React.createElement(VegaLite, {\n    spec: comp_2\n  }), \"\\n\", React.createElement(_components.h3, null, \"Model 3\"), \"\\n\", React.createElement(VegaLite, {\n    spec: comp_3\n  }), \"\\n\", React.createElement(_components.h3, null, \"Model 4\"), \"\\n\", React.createElement(VegaLite, {\n    spec: comp_4\n  }), \"\\n\", React.createElement(_components.h3, null, \"Model 5\"), \"\\n\", React.createElement(VegaLite, {\n    spec: comp_5\n  }));\n}\nfunction MDXContent(props = {}) {\n  return React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props));\n}\nexport default MDXContent;\n","import React from 'react';\n\nconst Subtitle = ({ children }) => {\n    const newChildren = React.Children.map(children, child => {\n        if (React.isValidElement(child) && child.type === 'p') {\n            // Remove the <p> wrapper that mdx adds by default\n            return child.props.children;\n        }\n        return child;\n    });\n\n    return (\n        <h2 className=\"text-lg font-sans font-normal text-gray-500\">\n            {newChildren}\n        </h2>\n    );\n};\n\nexport default Subtitle;\n"],"names":["Head","props","React","SEO","frontmatter","pageContext","_createMdxContent","_components","Object","assign","h1","h2","p","a","h3","_provideComponents","components","Subtitle","href","VegaLite","spec","roc_comparison_cluster","roc_comparison_no_cluster","iterations","comp_1","comp_2","comp_3","comp_4","comp_5","MDXLayout","_ref","children","newChildren","map","child","type","className"],"sourceRoot":""}